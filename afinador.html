<!DOCTYPE html>
<html lang="es" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Afinador de Guitarra</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilo para la aguja del afinador */
        #needle {
            width: 4px;
            height: 100px;
            background-color: #f87171; /* Rojo */
            position: absolute;
            left: 50%;
            bottom: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.1s ease-out;
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px #f87171;
        }

        /* La zona "en tono" */
        #needle.in-tune {
            background-color: #4ade80; /* Verde */
            box-shadow: 0 0 10px #4ade80;
        }

        /* Marcas del medidor */
        .meter-mark {
            position: absolute;
            bottom: 10px;
            width: 2px;
            height: 10px;
            background-color: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center h-full font-sans p-4">

    <div class="w-full max-w-sm text-center">
        <h1 class="text-4xl font-bold mb-8">Afinador Cromático</h1>

        <!-- Contenedor del medidor visual -->
        <div id="meter-container" class="relative w-full h-40 bg-gray-800 rounded-lg overflow-hidden mb-6 p-4 border border-gray-700">
            <!-- Marcas de afinación -->
            <div class="meter-mark" style="left: 10%;"></div>
            <div class="meter-mark" style="left: 30%;"></div>
            <div class="meter-mark bg-white h-20" style="left: 50%; transform: translateX(-1px);"></div> <!-- Centro -->
            <div class="meter-mark" style="left: 70%;"></div>
            <div class="meter-mark" style="left: 90%;"></div>

            <!-- La aguja -->
            <div id="needle"></div>
        </div>

        <!-- Pantalla de la nota -->
        <div class="mb-8">
            <div id="note-display" class="text-8xl font-bold text-gray-400">--</div>
            <div id="detune-display" class="text-2xl text-gray-500">Toca una cuerda</div>
        </div>

        <!-- Botón de inicio -->
        <button id="startButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-all">
            Comenzar
        </button>

        <!-- Mensaje de error -->
        <div id="error-message" class="text-red-500 mt-4 hidden"></div>

        <!-- Notas de referencia (para el usuario) -->
        <div class="mt-8 text-gray-500">
            <p class="text-lg mb-2">Afinación Estándar (EADGBe)</p>
            <div class="flex justify-center space-x-4">
                <span>E (6ª)</span>
                <span>A (5ª)</span>
                <span>D (4ª)</span>
                <span>G (3ª)</span>
                <span>B (2ª)</span>
                <span>e (1ª)</span>
            </div>
        </div>
    </div>

    <script>
        // Referencias del DOM
        const startButton = document.getElementById('startButton');
        const noteDisplay = document.getElementById('note-display');
        const detuneDisplay = document.getElementById('detune-display');
        const needle = document.getElementById('needle');
        const errorMessage = document.getElementById('error-message');

        // Configuración de Audio
        let audioContext;
        let analyser;
        let mediaStreamSource;
        let bufferLength;
        let dataArray;

        // Nombres de las notas
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        // Estado
        let isRunning = false;
        let rafID; // ID para requestAnimationFrame

        startButton.addEventListener('click', () => {
            if (!isRunning) {
                setupAudioContext();
            } else {
                stopTuner();
            }
        });

        function setupAudioContext() {
            // Compatibilidad de navegador
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            
            // Solicitar acceso al micrófono
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    audioContext = new AudioContext();
                    analyser = audioContext.createAnalyser();
                    mediaStreamSource = audioContext.createMediaStreamSource(stream);
                    
                    // Configurar el analizador
                    analyser.fftSize = 4096; // Alta resolución para bajas frecuencias
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Float32Array(analyser.fftSize); // Usar Float32Array para TimeDomainData
                    
                    // Conectar los nodos
                    mediaStreamSource.connect(analyser);
                    
                    // Iniciar el bucle de detección
                    isRunning = true;
                    startButton.textContent = 'Detener';
                    errorMessage.classList.add('hidden');
                    detectPitch();
                })
                .catch(err => {
                    console.error('Error al obtener el micrófono:', err);
                    errorMessage.textContent = 'Error: No se pudo acceder al micrófono. Asegúrate de dar permiso.';
                    errorMessage.classList.remove('hidden');
                });
        }

        function stopTuner() {
            if (rafID) {
                cancelAnimationFrame(rafID);
            }
            if (mediaStreamSource && mediaStreamSource.mediaStream.getTracks) {
                mediaStreamSource.mediaStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
            }
            
            isRunning = false;
            startButton.textContent = 'Comenzar';
            noteDisplay.textContent = '--';
            detuneDisplay.textContent = 'Toca una cuerda';
            updateMeter(0);
        }

        function detectPitch() {
            analyser.getFloatTimeDomainData(dataArray);
            
            // Llamar al algoritmo de autocorrelación
            const frequency = autoCorrelate(dataArray, audioContext.sampleRate);
            
            if (frequency > 0) {
                // Frecuencia detectada
                const noteData = getNoteData(frequency);
                updateUI(noteData);
            } else {
                // Silencio o ruido no identificable
                noteDisplay.textContent = '--';
                detuneDisplay.textContent = 'Toca una cuerda';
                updateMeter(0);
            }

            // Continuar el bucle
            rafID = requestAnimationFrame(detectPitch);
        }

        function updateUI(noteData) {
            const { noteName, detune } = noteData;
            
            noteDisplay.textContent = noteName;
            
            if (Math.abs(detune) < 5) { // Rango "en tono" (5 cents)
                detuneDisplay.textContent = 'En Tono';
                noteDisplay.classList.remove('text-gray-400', 'text-red-500');
                noteDisplay.classList.add('text-green-400');
            } else if (detune < 0) {
                detuneDisplay.textContent = `${Math.abs(detune).toFixed(0)} cents (Bajo)`;
                noteDisplay.classList.remove('text-gray-400', 'text-green-400');
                noteDisplay.classList.add('text-red-500');
            } else {
                detuneDisplay.textContent = `${detune.toFixed(0)} cents (Alto)`;
                noteDisplay.classList.remove('text-gray-400', 'text-green-400');
                noteDisplay.classList.add('text-red-500');
            }
            
            updateMeter(detune);
        }

        function updateMeter(detune) {
            // Mapear 'detune' (rango -50 a +50 cents) a un ángulo (rango -45 a +45 grados)
            let rotation = detune * 0.9; // 50 cents = 45 grados
            
            // Limitar el ángulo
            rotation = Math.max(-45, Math.min(45, rotation));
            
            needle.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
            
            if (Math.abs(detune) < 5) {
                needle.classList.add('in-tune');
            } else {
                needle.classList.remove('in-tune');
            }
        }

        function getNoteData(frequency) {
            // Fórmula para convertir frecuencia a número de nota MIDI
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2)) + 69;
            const nearestNote = Math.round(noteNum);
            
            const noteName = noteStrings[nearestNote % 12];
            
            // Calcular la diferencia en cents
            // cents = 1200 * log2(f2 / f1)
            const expectedFrequency = 440 * Math.pow(2, (nearestNote - 69) / 12);
            const detune = 1200 * Math.log2(frequency / expectedFrequency);
            
            return { noteName, detune };
        }

        // --- Algoritmo de Autocorrelación ---
        // Esta es la parte más compleja. Busca la frecuencia fundamental
        // analizando la periodicidad de la señal de audio.
        function autoCorrelate(buffer, sampleRate) {
            // 1. Encontrar el RMS (Root Mean Square) para detectar silencio
            let rms = 0;
            for (let i = 0; i < buffer.length; i++) {
                rms += buffer[i] * buffer[i];
            }
            rms = Math.sqrt(rms / buffer.length);
            
            if (rms < 0.01) { // Umbral de silencio (ajustar si es necesario)
                return -1; // Silencio
            }

            // 2. Encontrar el rango de búsqueda (basado en frecuencias de guitarra)
            const minFreq = 70; // E2 (approx 82Hz, damos margen)
            const maxFreq = 700; // E5 (approx 659Hz, damos margen)
            const minSamples = Math.floor(sampleRate / maxFreq);
            const maxSamples = Math.floor(sampleRate / minFreq);

            let bestOffset = -1;
            let bestCorrelation = 0;
            let correlations = new Array(maxSamples).fill(0);

            // 3. Calcular la autocorrelación (comparar el buffer consigo mismo en diferentes desfases)
            for (let offset = minSamples; offset < maxSamples; offset++) {
                let correlation = 0;
                for (let i = 0; i < buffer.length - offset; i++) {
                    correlation += buffer[i] * buffer[i + offset];
                }
                
                // Normalización (diferencia cuadrática media)
                let sum = 0;
                for (let i = 0; i < buffer.length - offset; i++) {
                    sum += buffer[i] * buffer[i] + buffer[i+offset] * buffer[i+offset];
                }
                correlations[offset] = (2 * correlation) / sum;
                
                if (correlations[offset] > bestCorrelation) {
                    bestCorrelation = correlations[offset];
                    bestOffset = offset;
                }
            }

            if (bestCorrelation > 0.9) { // Umbral de confianza (ajustar si es necesario)
                // 4. Interpolación cuadrática para una mejor precisión
                // (Encontrar el pico exacto entre muestras)
                const d1 = correlations[bestOffset - 1];
                const d2 = correlations[bestOffset];
                const d3 = correlations[bestOffset + 1];
                const shift = (d1 - d3) / (2 * (2 * d2 - d1 - d3));
                
                return sampleRate / (bestOffset + shift);
            }

            return -1; // No se encontró un tono claro
        }
    </script>
</body>
</html>