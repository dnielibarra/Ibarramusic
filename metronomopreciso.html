<!DOCTYPE html>
<html lang="es" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metrónomo Web</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos específicos para los puntos de beat */
        .beat-dot {
            width: 20px;
            height: 20px;
            background-color: #4b5563; /* gray-600, color apagado por defecto */
            border-radius: 50%;
            transition: background-color 0.1s ease-out, transform 0.1s ease-out;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Estilo para el indicador de beat actual, ahora innecesario, pero lo mantenemos si se desea usar */
        #beat-indicator {
            transition: all 0.1s;
        }

        /* Colores de Resalte */
        .dot-strong-beat {
            background-color: #ef4444; /* Rojo para el beat 1 (Acento) */
            transform: scale(1.3);
            box-shadow: 0 0 15px #ef4444;
        }
        .dot-weak-beat {
            background-color: #facc15; /* Amarillo para los beats débiles */
            transform: scale(1.1);
            box-shadow: 0 0 10px #facc15;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center h-full font-sans p-4">

    <div class="w-full max-w-lg text-center bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700">
        <h1 class="text-4xl font-extrabold mb-6 text-blue-400">Metrónomo Preciso</h1>

        <!-- Puntos Dinámicos de Beats -->
        <div class="mb-10 p-4">
            <div id="beat-dots-container" class="flex justify-center space-x-3 h-10 items-center">
                <!-- Los puntos (bolitas) se insertarán aquí por JavaScript -->
            </div>
            <p id="beat-display" class="text-xl mt-2 text-gray-300">Compás: <span id="time-signature-display">4/4</span></p>
        </div>
        
        <!-- Pantalla de BPM -->
        <div class="mb-8 p-4 bg-gray-900 rounded-lg">
            <span id="bpm-display" class="text-9xl font-mono font-bold text-green-400">120</span>
            <span class="text-2xl text-gray-400">BPM</span>
        </div>

        <!-- Slider de BPM -->
        <input type="range" id="bpm-slider" min="40" max="240" value="120" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">

        <!-- Controles de Compás (Time Signature) -->
        <div class="flex justify-center space-x-4 mt-8">
            <select id="time-signature" class="bg-gray-700 text-white p-3 rounded-lg text-lg focus:ring-blue-500 focus:border-blue-500">
                <option value="4/4">4/4</option>
                <option value="3/4">3/4</option>
                <option value="2/4">2/4</option>
                <option value="6/8">6/8</option>
            </select>
            <button id="startStopButton" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-all shadow-lg hover:shadow-xl">
                Comenzar
            </button>
        </div>
        
        <p id="error-message" class="text-red-500 mt-4 hidden text-sm">El acceso al audio requiere interacción del usuario. Toca "Comenzar".</p>

    </div>

    <script>
        // --- Variables Globales ---
        let audioContext = null;
        let isRunning = false;
        let tempo = 120; // Beats Per Minute
        
        // Variables para la firma de tiempo (compás)
        let beatsPerMeasure = 4;
        const noteValue = 4; 

        // Variables para el scheduler (programador de audio)
        let lookahead = 25.0; // Milisegundos que miramos adelante
        let scheduleAheadTime = 0.1; // Segundos (máximo de 100ms)
        let nextNoteTime = 0.0; // Hora en segundos del AudioContext para la próxima nota
        let currentBeat = 0;
        let timerID;

        // --- Referencias del DOM ---
        const startStopButton = document.getElementById('startStopButton');
        const bpmSlider = document.getElementById('bpm-slider');
        const bpmDisplay = document.getElementById('bpm-display');
        const timeSignatureSelect = document.getElementById('time-signature');
        const beatDotsContainer = document.getElementById('beat-dots-container');
        const timeSignatureDisplay = document.getElementById('time-signature-display');
        
        // --- Funciones de Control Visual ---
        
        /**
         * Renderiza los puntos de beat según el compás actual.
         */
        function renderDots() {
            beatDotsContainer.innerHTML = '';
            for (let i = 1; i <= beatsPerMeasure; i++) {
                const dot = document.createElement('div');
                dot.classList.add('beat-dot');
                dot.setAttribute('data-beat', i);
                beatDotsContainer.appendChild(dot);
            }
            timeSignatureDisplay.textContent = timeSignatureSelect.value;
        }

        /**
         * Reinicia el estado visual de todos los puntos al color apagado.
         */
        function resetDotsVisuals() {
             const dots = beatDotsContainer.querySelectorAll('.beat-dot');
             dots.forEach(dot => {
                dot.classList.remove('dot-strong-beat', 'dot-weak-beat');
                dot.classList.remove('scale-130', 'scale-110');
             });
        }


        // --- Manejadores de Eventos ---
        bpmSlider.addEventListener('input', (e) => {
            tempo = parseInt(e.target.value);
            bpmDisplay.textContent = tempo;
        });

        startStopButton.addEventListener('click', () => {
            if (!isRunning) {
                startMetronome();
            } else {
                stopMetronome();
            }
        });

        timeSignatureSelect.addEventListener('change', (e) => {
            const [beats, value] = e.target.value.split('/');
            beatsPerMeasure = parseInt(beats);
            currentBeat = 0; // Reiniciar el contador de beat
            
            renderDots(); // Rerenderiza la cantidad correcta de puntos
            
            // Si está corriendo, reinicia para aplicar el nuevo compás
            if (isRunning) {
                stopMetronome();
                startMetronome();
            }
        });

        // --- Funciones de Audio y Timing ---

        function playClick(time, isStrong) {
            // Creamos un simple tono de onda cuadrada para el click
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Conexiones
            osc.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Tono (más alto para el beat fuerte)
            osc.type = 'square';
            osc.frequency.setValueAtTime(isStrong ? 880 : 440, time); // A5 o A4

            // Volumen (más alto para el beat fuerte)
            const volume = isStrong ? 0.9 : 0.5;
            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(volume, time + 0.001); // Ataque rápido
            gainNode.gain.linearRampToValueAtTime(0, time + 0.05); // Decaimiento rápido
            
            // Tocar y parar
            osc.start(time);
            osc.stop(time + 0.05);
        }

        /**
         * Avanza el contador del beat al siguiente número del compás.
         */
        function nextBeat() {
            currentBeat++;
            if (currentBeat > beatsPerMeasure) {
                currentBeat = 1;
            }
        }

        function scheduleNote(beatNumber, time) {
            const isStrongBeat = (beatNumber === 1);
            
            // 1. Generar el sonido
            playClick(time, isStrongBeat);
            
            // 2. Programar la actualización visual (esto debe ser en el hilo principal)
            const delayInMs = (time - audioContext.currentTime) * 1000;
            
            // La actualización visual de los puntos de beat
            setTimeout(() => {
                updateVisuals(beatNumber, isStrongBeat);
            }, delayInMs);
        }

        function scheduler() {
            // Mientras haya notas que deban ser programadas en el futuro cercano...
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                
                // 1. Avanzar el beat (0->1, 1->2, 2->3, 3->4, 4->1...)
                nextBeat(); 

                // 2. Programar la nota actual (YA con el beat correcto)
                scheduleNote(currentBeat, nextNoteTime);
                
                // 3. Avanzar el tiempo para la próxima nota
                const secondsPerBeat = 60.0 / tempo;
                nextNoteTime += secondsPerBeat;
            }
            // Llamar de nuevo al scheduler
            timerID = setTimeout(scheduler, lookahead);
        }

        function updateVisuals(beat, isStrong) {
            resetDotsVisuals();
            
            // Seleccionar el dot actual
            const currentDot = beatDotsContainer.querySelector(`[data-beat="${beat}"]`);

            if (currentDot) {
                // Aplicar el estilo de acento o débil
                if (isStrong) {
                    currentDot.classList.add('dot-strong-beat');
                } else {
                    currentDot.classList.add('dot-weak-beat');
                }

                // Programar el reset visual después de un pequeño retraso
                const secondsPerBeat = 60.0 / tempo;
                const resetDelay = secondsPerBeat * 1000 * 0.15; // 15% del tiempo de beat

                setTimeout(() => {
                    currentDot.classList.remove('dot-strong-beat', 'dot-weak-beat');
                }, resetDelay);
            }
        }

        // --- Funciones de Control ---

        function startMetronome() {
            // Inicializar AudioContext si no existe
            if (audioContext === null || audioContext.state === 'closed') {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
            }
            
            // Reanudar si está suspendido (necesario en muchos navegadores móviles)
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => {
                    document.getElementById('error-message').classList.remove('hidden');
                    console.error("No se pudo reanudar el AudioContext:", e);
                });
            }

            // --- CORRECCIÓN FINAL PARA EVITAR SALTO DEL BEAT 1 ---
            currentBeat = 0; // Inicia en 0 para que la primera llamada a nextBeat lo ponga en 1.
            
            // Programamos el primer beat 50ms en el futuro (tiempo suficiente para "despertar" el sistema)
            nextNoteTime = audioContext.currentTime + 0.05; 
            
            // Iniciar el programador (la primera ejecución de scheduler programará el Beat 1 en nextNoteTime)
            isRunning = true;
            startStopButton.textContent = 'Detener';
            startStopButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            startStopButton.classList.add('bg-red-600', 'hover:bg-red-700');
            document.getElementById('error-message').classList.add('hidden');
            
            timerID = setTimeout(scheduler, lookahead);
        }

        function stopMetronome() {
            isRunning = false;
            clearTimeout(timerID);
            
            // Resetear UI
            startStopButton.textContent = 'Comenzar';
            startStopButton.classList.remove('bg-red-600', 'hover:bg-red-700');
            startStopButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
            
            // ** RESET: Apagar todos los dots visualmente al detener **
            resetDotsVisuals();

            // Cerrar AudioContext para liberar recursos (Opcional, pero buena práctica)
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
                audioContext = null;
            }
        }

        // Inicializar el display de compás y renderizar dots al cargar
        document.addEventListener('DOMContentLoaded', () => {
            renderDots();
            bpmDisplay.textContent = bpmSlider.value;
        });

    </script>
</body>
</html>
