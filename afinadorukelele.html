<!DOCTYPE html>
<html lang="es" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Afinador Visual de Ukelele</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos generales y la barra de afinaci贸n */
        .tuner-container {
            background-color: #1f2937; /* Gray 800 */
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        .string-label {
            transition: all 0.2s;
        }
        #tuner-canvas {
            background-color: #374151; /* Gray 700 */
            border-radius: 8px;
            margin: 20px 0;
            width: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center h-full font-sans p-4">

    <div class="w-full max-w-lg text-center tuner-container p-8 border border-gray-700">
        <h1 class="text-3xl font-extrabold mb-2 text-emerald-400"> Afinador Visual de Ukelele</h1>
        <p class="text-gray-400 mb-6">Afinaci贸n est谩ndar: G4 C4 E4 A4. Toca "Iniciar Afinador" y permite el acceso al micr贸fono.</p>

        <!-- Bot贸n de Inicio y Mensaje de Estado -->
        <button id="start-tuner-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-all shadow-lg hover:shadow-xl disabled:bg-gray-600">
            Iniciar Afinador
        </button>
        <p id="status-message" class="text-lg font-semibold h-6 mt-4 text-yellow-400">Pulsa para iniciar el micr贸fono...</p>

        <!-- Diagrama de Cuerdas de Ukelele -->
        <div id="strings-diagram" class="mt-8 flex justify-between items-center px-4">
            <!-- Cuerdas: G4 C4 E4 A4 -->
            <div data-target="G4" class="string-label w-1/4 flex flex-col items-center">
                <div class="text-3xl font-bold text-gray-300">4陋</div>
                <div class="text-base text-gray-400" id="label-G4">G4</div>
            </div>
            <div data-target="C4" class="string-label w-1/4 flex flex-col items-center">
                <div class="text-3xl font-bold text-gray-300">3陋</div>
                <div class="text-base text-gray-400" id="label-C4">C4</div>
            </div>
            <div data-target="E4" class="string-label w-1/4 flex flex-col items-center">
                <div class="text-3xl font-bold text-gray-300">2陋</div>
                <div class="text-base text-gray-400" id="label-E4">E4</div>
            </div>
            <div data-target="A4" class="string-label w-1/4 flex flex-col items-center">
                <div class="text-3xl font-bold text-gray-300">1陋</div>
                <div class="text-base text-gray-400" id="label-A4">A4</div>
            </div>
        </div>

        <!-- Canvas para el Medidor de Afinaci贸n -->
        <canvas id="tuner-canvas" height="150" width="400"></canvas>

        <!-- Display de Nota Detectada -->
        <div class="mt-2">
            <p class="text-sm text-gray-400">Nota Detectada</p>
            <div id="detected-note" class="text-6xl font-extrabold text-white">---</div>
            <p id="frequency-display" class="text-xl font-mono text-gray-500">0.0 Hz</p>
        </div>

    </div>

    <script>
        // --- Constantes de Afinaci贸n ---
        const A4_FREQ = 440; 
        const MIDI_A4 = 69;
        
        // Afinaci贸n Est谩ndar de Ukelele (G C E A)
        const UKE_TUNING = [
            { name: "A4", midi: 69, freq: 440.00, id: 'label-A4' }, // Cuerda 1
            { name: "E4", midi: 64, freq: 329.63, id: 'label-E4' }, // Cuerda 2
            { name: "C4", midi: 60, freq: 261.63, id: 'label-C4' }, // Cuerda 3
            { name: "G4", midi: 67, freq: 392.00, id: 'label-G4' }  // Cuerda 4 (High G)
        ];

        // --- Configuraci贸n de Audio ---
        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let dataArray = null;
        let pitchDetectionInterval = null;
        
        // --- Referencias DOM y Canvas ---
        const statusMessage = document.getElementById('status-message');
        const startTunerButton = document.getElementById('start-tuner-button');
        const detectedNoteDisplay = document.getElementById('detected-note');
        const frequencyDisplay = document.getElementById('frequency-display');
        const stringLabels = document.querySelectorAll('.string-label');
        const canvas = document.getElementById('tuner-canvas');
        const canvasCtx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- Funciones Musicales ---

        /**
         * Convierte la frecuencia a una nota MIDI.
         * @param {number} freq Frecuencia en Hz.
         * @returns {number} N煤mero MIDI.
         */
        function freqToMidi(freq) {
            return MIDI_A4 + (12 * Math.log2(freq / A4_FREQ));
        }

        /**
         * Convierte la nota MIDI a frecuencia.
         * @param {number} midi N煤mero MIDI.
         * @returns {number} Frecuencia en Hz.
         */
        function midiToFreq(midi) {
            return A4_FREQ * Math.pow(2, (midi - MIDI_A4) / 12);
        }

        /**
         * Calcula los cents de desviaci贸n.
         * @param {number} freq Frecuencia detectada.
         * @param {number} targetFreq Frecuencia objetivo (perfecta).
         * @returns {number} Desviaci贸n en cents (-50 a +50).
         */
        function centsOff(freq, targetFreq) {
            return 1200 * Math.log2(freq / targetFreq);
        }

        /**
         * Encuentra la frecuencia objetivo m谩s cercana dentro de un rango de notas.
         * @param {number} freq Frecuencia detectada.
         * @returns {object|null} Objeto de nota objetivo m谩s cercana.
         */
        function getClosestTarget(freq) {
            if (freq < 150) return null; // Ignorar ruido muy bajo

            let closest = null;
            let minCents = 1200; // Inicializar alto

            UKE_TUNING.forEach(target => {
                const cents = Math.abs(centsOff(freq, target.freq));
                if (cents < minCents) {
                    minCents = cents;
                    closest = target;
                }
            });

            return closest;
        }

        // --- Funciones de Detecci贸n de Tono (Autocorrelaci贸n simplificada) ---

        /**
         * Funci贸n b谩sica para la detecci贸n de tono (Autocorrelaci贸n simplificada).
         * Basado en la t茅cnica de Zero-Crossing para encontrar el per铆odo.
         * @param {Float32Array} buffer Array de datos de audio.
         * @param {number} sampleRate Tasa de muestreo del AudioContext.
         * @returns {number} Frecuencia fundamental detectada en Hz.
         */
        function getFundamentalFreq(buffer, sampleRate) {
            const size = buffer.length;
            const threshold = 0.05; // Umbral de amplitud para el inicio
            let startIndex = 0;

            // Encontrar el primer punto por encima del umbral (para evitar ruido inicial)
            for (let i = 0; i < size; i++) {
                if (Math.abs(buffer[i]) > threshold) {
                    startIndex = i;
                    break;
                }
            }
            if (startIndex === 0) return 0; // Silencio o muy bajo

            // Autocorrelaci贸n simplificada
            let maxCorr = -1;
            let bestPeriod = -1;

            // Rango de b煤squeda: de 1/freq_max a 1/freq_min (Ukelele: ~200Hz a 500Hz)
            const minPeriod = sampleRate / 500;
            const maxPeriod = sampleRate / 200;

            for (let tau = Math.floor(minPeriod); tau <= Math.floor(maxPeriod); tau++) {
                let correlation = 0;
                for (let i = startIndex; i < size - tau; i++) {
                    correlation += buffer[i] * buffer[i + tau];
                }
                if (correlation > maxCorr) {
                    maxCorr = correlation;
                    bestPeriod = tau;
                }
            }

            if (bestPeriod > 0 && maxCorr > (0.1 * size)) { // Filtro de calidad
                return sampleRate / bestPeriod;
            }
            return 0; 
        }

        // --- Funciones de Dibujo (Canvas) ---

        /**
         * Dibuja el medidor de afinaci贸n en el Canvas.
         * @param {number} cents Desviaci贸n en cents.
         */
        function drawTuner(cents) {
            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // 1. Dibujar l铆nea central (perfecto)
            const center = WIDTH / 2;
            canvasCtx.fillStyle = '#6b7280'; // Gris (luz tenue)
            canvasCtx.fillRect(center - 1, 0, 2, HEIGHT);

            // 2. Dibujar marcas de referencia
            const markColor = '#4b5563';
            const markHeight = HEIGHT * 0.2;
            const markPositions = [-30, -20, -10, 10, 20, 30]; // Cents de desviaci贸n
            
            markPositions.forEach(c => {
                const x = center + (c / 50) * (center * 0.8); 
                canvasCtx.fillStyle = markColor;
                canvasCtx.fillRect(x - 0.5, HEIGHT - markHeight, 1, markHeight);
            });

            // 3. Dibujar la aguja de afinaci贸n (o barra)
            let drawCents = Math.min(Math.max(cents, -50), 50); // Limitar a +/- 50 cents
            let needleX = center + (drawCents / 50) * (center * 0.8);
            
            let color;
            const absCents = Math.abs(drawCents);

            if (absCents <= 5) { // Verde: Perfecto
                color = '#10b981'; 
            } else if (absCents <= 20) { // Amarillo: Cerca
                color = '#f59e0b'; 
            } else { // Rojo: Desafinado
                color = '#ef4444'; 
            }

            // Aguja: un rect谩ngulo que se mueve
            canvasCtx.fillStyle = color;
            canvasCtx.shadowColor = color;
            canvasCtx.shadowBlur = 10;
            canvasCtx.fillRect(needleX - 5, 0, 10, HEIGHT);
            canvasCtx.shadowBlur = 0; // Resetear sombra
        }

        /**
         * Bucle principal que analiza el audio y actualiza la UI.
         */
        function tick() {
            if (!analyser || !dataArray) {
                pitchDetectionInterval = requestAnimationFrame(tick);
                return;
            }

            analyser.getFloatTimeDomainData(dataArray);
            const sampleRate = audioContext.sampleRate;
            
            let detectedFreq = getFundamentalFreq(dataArray, sampleRate);
            let closestTarget = null;
            let cents = 0;

            // Limpiar colores anteriores
            stringLabels.forEach(label => {
                const targetName = label.getAttribute('data-target');
                document.getElementById('label-' + targetName).classList.remove('text-emerald-400', 'text-yellow-400');
                document.getElementById('label-' + targetName).classList.add('text-gray-400');
            });


            if (detectedFreq > 0) {
                closestTarget = getClosestTarget(detectedFreq);
                
                if (closestTarget) {
                    cents = centsOff(detectedFreq, closestTarget.freq);
                    
                    // Actualizar Display de Nota
                    const midiNote = freqToMidi(detectedFreq);
                    const noteIndex = Math.round(midiNote) % 12;
                    const detectedNoteName = NOTE_NAMES[noteIndex];
                    
                    detectedNoteDisplay.textContent = detectedNoteName;
                    frequencyDisplay.textContent = `${detectedFreq.toFixed(2)} Hz`;

                    // Resaltar cuerda objetivo
                    const labelElement = document.getElementById(closestTarget.id);
                    if (labelElement) {
                        const absCents = Math.abs(cents);
                        labelElement.classList.remove('text-gray-400');
                        if (absCents <= 5) {
                            labelElement.classList.add('text-emerald-400'); // Verde: 隆Afinado!
                        } else {
                            labelElement.classList.add('text-yellow-400'); // Amarillo: Cerca
                        }
                    }

                } else {
                    // Nota detectada pero fuera de las cuerdas de ukelele
                    detectedNoteDisplay.textContent = 'Fuera de rango';
                    frequencyDisplay.textContent = `${detectedFreq.toFixed(2)} Hz`;
                    cents = 0; // Barra al centro
                }
            } else {
                // Silencio
                detectedNoteDisplay.textContent = '---';
                frequencyDisplay.textContent = '0.0 Hz';
                cents = 0; // Barra al centro
            }

            // Dibujar Canvas
            drawTuner(cents);
            
            pitchDetectionInterval = requestAnimationFrame(tick);
        }

        // --- Inicializaci贸n y Event Handlers ---
        
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];


        /**
         * Inicia el acceso al micr贸fono y el bucle de afinaci贸n.
         */
        async function startTuner() {
            startTunerButton.disabled = true;
            statusMessage.textContent = 'Solicitando acceso al micr贸fono...';

            try {
                audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Tama帽o de FFT para la precisi贸n
                dataArray = new Float32Array(analyser.fftSize);

                source.connect(analyser);

                statusMessage.textContent = 'Micr贸fono activo. Toca una cuerda para afinar.';
                startTunerButton.textContent = 'Afinador Activo';
                startTunerButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                startTunerButton.classList.add('bg-emerald-600');

                // Iniciar el bucle de detecci贸n de tono
                tick(); 

            } catch (err) {
                console.error("Error al acceder al micr贸fono:", err);
                statusMessage.textContent = 'Error: No se pudo acceder al micr贸fono. Recarga la p谩gina y permite el acceso.';
                statusMessage.classList.remove('text-yellow-400');
                statusMessage.classList.add('text-red-500');
                startTunerButton.disabled = false;
                startTunerButton.textContent = 'Reintentar';
            }
        }

        startTunerButton.addEventListener('click', startTuner);

    </script>
</body>
</html>
